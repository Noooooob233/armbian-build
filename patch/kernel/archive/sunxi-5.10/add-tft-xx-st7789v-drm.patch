From e73a9050cdb001dabbb5e8d2d26d74ac542babfd Mon Sep 17 00:00:00 2001
From: Noooooob233 <493281372@qq.com>
Date: Thu, 9 Dec 2021 17:29:10 +0800
Subject: [PATCH] add st7789v drm driver

---
 drivers/gpu/drm/tiny/Kconfig   |  15 ++
 drivers/gpu/drm/tiny/Makefile  |   1 +
 drivers/gpu/drm/tiny/st7789v.c | 281 +++++++++++++++++++++++++++++++++
 3 files changed, 295 insertions(+)
 create mode 100644 drivers/gpu/drm/tiny/st7789v.c

diff --git a/drivers/gpu/drm/tiny/Kconfig b/drivers/gpu/drm/tiny/Kconfig
index 2b6414f0f..e51cb151e 100644
--- a/drivers/gpu/drm/tiny/Kconfig
+++ b/drivers/gpu/drm/tiny/Kconfig
@@ -131,3 +131,18 @@ config TINYDRM_ST7735R
 	  * Okaya RH128128T 1.44" 128x128 TFT
 
 	  If M is selected the module will be called st7735r.
+
+config TINYDRM_ST7789V
+        tristate "DRM support for Sitronix ST7789V display panels"
+        depends on DRM && SPI
+        select DRM_KMS_HELPER
+        select DRM_KMS_CMA_HELPER
+        select DRM_MIPI_DBI
+        select BACKLIGHT_CLASS_DEVICE
+        help
+          DRM driver for Sitronix ST7789V with one of the following
+          LCDs:
+          * ST7789V 1.14" 240*135 TFT          
+          * ST7789V 1.3" 240*240 TFT
+
+          If M is selected the module will be called st7789v.
diff --git a/drivers/gpu/drm/tiny/Makefile b/drivers/gpu/drm/tiny/Makefile
index 6ae4e9e5a..83de46a33 100644
--- a/drivers/gpu/drm/tiny/Makefile
+++ b/drivers/gpu/drm/tiny/Makefile
@@ -10,3 +10,4 @@ obj-$(CONFIG_TINYDRM_MI0283QT)		+= mi0283qt.o
 obj-$(CONFIG_TINYDRM_REPAPER)		+= repaper.o
 obj-$(CONFIG_TINYDRM_ST7586)		+= st7586.o
 obj-$(CONFIG_TINYDRM_ST7735R)		+= st7735r.o
+obj-$(CONFIG_TINYDRM_ST7789V)          += st7789v.o
diff --git a/drivers/gpu/drm/tiny/st7789v.c b/drivers/gpu/drm/tiny/st7789v.c
new file mode 100644
index 000000000..d10af79f0
--- /dev/null
+++ b/drivers/gpu/drm/tiny/st7789v.c
@@ -0,0 +1,281 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * DRM driver for display panels connected to a Sitronix ST7789V
+ * display controller in SPI mode.
+ *
+ * Copyright 2021 Major Tom <493281372@qq.com>
+ */
+
+#include <linux/backlight.h>
+#include <linux/delay.h>
+#include <linux/dma-buf.h>
+#include <linux/gpio/consumer.h>
+#include <linux/module.h>
+#include <linux/property.h>
+#include <linux/spi/spi.h>
+#include <video/mipi_display.h>
+
+#include <drm/drm_atomic_helper.h>
+#include <drm/drm_drv.h>
+#include <drm/drm_fb_helper.h>
+#include <drm/drm_gem_cma_helper.h>
+#include <drm/drm_gem_framebuffer_helper.h>
+#include <drm/drm_managed.h>
+#include <drm/drm_mipi_dbi.h>
+
+enum st7789v_command {
+        PORCTRL = 0xB2,
+        GCTRL = 0xB7,
+        VCOMS = 0xBB,
+        LCMCTRL = 0xC0,
+        VDVVRHEN = 0xC2,
+        VRHS = 0xC3,
+        VDVS = 0xC4,
+        VCMOFSET = 0xC5,
+        FRCTRL2 = 0xC6,
+        PWCTRL1 = 0xD0,
+        PVGAMCTRL = 0xE0,
+        NVGAMCTRL = 0xE1,
+};
+
+#define ST7789V_MY	BIT(7)
+#define ST7789V_MX	BIT(6)
+#define ST7789V_MV	BIT(5)
+#define ST7789V_RGB	BIT(3)
+
+struct st7789v_cfg_t {
+	const struct drm_display_mode mode;
+	unsigned int left_offset;
+	unsigned int top_offset;
+	unsigned int write_only:1;
+	unsigned int rgb:1;		/* RGB (vs. BGR) */
+};
+
+struct st7789v_priv {
+	struct mipi_dbi_dev dbidev;	/* Must be first for .release() */
+	const struct st7789v_cfg_t *cfg;
+};
+
+static void st7789v_pipe_enable(struct drm_simple_display_pipe *pipe,
+				struct drm_crtc_state *crtc_state,
+				struct drm_plane_state *plane_state)
+{
+	struct mipi_dbi_dev *dbidev = drm_to_mipi_dbi_dev(pipe->crtc.dev);
+	struct st7789v_priv *priv = container_of(dbidev, struct st7789v_priv,
+						 dbidev);
+	struct mipi_dbi *dbi = &dbidev->dbi;
+	int ret, idx;
+	u8 addr_mode;
+
+	if (!drm_dev_enter(pipe->crtc.dev, &idx))
+		return;
+
+	DRM_DEBUG_KMS("\n");
+
+	ret = mipi_dbi_poweron_reset(dbidev);
+	if (ret)
+		goto out_exit;
+
+	msleep(150);
+
+	mipi_dbi_command(dbi, MIPI_DCS_EXIT_SLEEP_MODE);
+	msleep(500);
+
+	switch (dbidev->rotation) {
+	default:
+		addr_mode = ST7789V_MY | ST7789V_MV;
+		break;
+	case 90:
+		addr_mode = ST7789V_MX | ST7789V_MY;
+		break;
+	case 180:
+		addr_mode = ST7789V_MX | ST7789V_MV;
+		break;
+	case 270:
+		addr_mode = 0;
+		break;
+	}
+
+	if (priv->cfg->rgb)
+		addr_mode |= ST7789V_RGB;
+
+	mipi_dbi_command(dbi, MIPI_DCS_SET_ADDRESS_MODE, addr_mode);
+
+	mipi_dbi_command(dbi, MIPI_DCS_SET_PIXEL_FORMAT, MIPI_DCS_PIXEL_FMT_16BIT);
+	mipi_dbi_command(dbi, PORCTRL, 0x0C, 0x0C, 0x00, 0x33, 0x33);
+	mipi_dbi_command(dbi, GCTRL, 0x35);
+	mipi_dbi_command(dbi, VCOMS, 0x19);
+	mipi_dbi_command(dbi, LCMCTRL, 0x2C);
+	mipi_dbi_command(dbi, VDVVRHEN, 0x01);
+	mipi_dbi_command(dbi, VRHS, 0x12);
+	mipi_dbi_command(dbi, VDVS, 0x20);
+	mipi_dbi_command(dbi, FRCTRL2, 0x0F);
+	mipi_dbi_command(dbi, PWCTRL1, 0xA4, 0xA1);
+
+	mipi_dbi_command(dbi, PVGAMCTRL, 0xD0, 0x04, 0x0D, 0x11, 0x13, 0x2B, 0x3F, 0x54, 0x4C, 0x18, 0x0D, 0x0B, 0x1F, 0x23);
+	mipi_dbi_command(dbi, NVGAMCTRL, 0xD0, 0x04, 0x0C, 0x11, 0x13, 0x2C, 0x3F, 0x44, 0x51, 0x2F, 0x1F, 0x1F, 0x20, 0x23);
+
+	mipi_dbi_command(dbi, MIPI_DCS_ENTER_INVERT_MODE);
+
+	mipi_dbi_command(dbi, MIPI_DCS_SET_DISPLAY_ON);
+
+	msleep(20);
+
+	mipi_dbi_enable_flush(dbidev, crtc_state, plane_state);
+
+out_exit:
+	drm_dev_exit(idx);
+}
+
+static const struct drm_simple_display_pipe_funcs st7789v_pipe_funcs = {
+	.enable		= st7789v_pipe_enable,
+	.disable	= mipi_dbi_pipe_disable,
+	.update		= mipi_dbi_pipe_update,
+	.prepare_fb	= drm_gem_fb_simple_display_pipe_prepare_fb,
+};
+
+static const struct st7789v_cfg_t st7789v_240x135_cfg = {
+	.mode		= { DRM_SIMPLE_MODE(240, 135, 31, 17) },
+	.left_offset	= 40,
+	.top_offset	= 52,
+	.rgb		= false,
+};
+
+static const struct st7789v_cfg_t st7789v_240x240_cfg = {
+	.mode		= { DRM_SIMPLE_MODE(240, 240, 29, 26) },
+	.left_offset	= 80,
+	.top_offset	= 0,
+	.rgb		= false,
+};
+
+DEFINE_DRM_GEM_CMA_FOPS(st7789v_fops);
+
+static struct drm_driver st7789v_driver = {
+	.driver_features	= DRIVER_GEM | DRIVER_MODESET | DRIVER_ATOMIC,
+	.fops			= &st7789v_fops,
+	DRM_GEM_CMA_DRIVER_OPS_VMAP,
+	.debugfs_init		= mipi_dbi_debugfs_init,
+	.name			= "st7789v",
+	.desc			= "Sitronix st7789v",
+	.date			= "20210802",
+	.major			= 1,
+	.minor			= 0,
+};
+
+static const struct of_device_id st7789v_of_match[] = {
+	{ .compatible = "sitronix,st7789v_240x135", .data = &st7789v_240x135_cfg },
+	{ .compatible = "sitronix,st7789v_240x240", .data = &st7789v_240x240_cfg },
+	{ },
+};
+MODULE_DEVICE_TABLE(of, st7789v_of_match);
+
+static const struct spi_device_id st7789v_id[] = {
+	{ "st7789v_240x135", (uintptr_t)&st7789v_240x135_cfg },
+	{ "st7789v_240x240", (uintptr_t)&st7789v_240x240_cfg },
+	{ },
+};
+MODULE_DEVICE_TABLE(spi, st7789v_id);
+
+static int st7789v_probe(struct spi_device *spi)
+{
+	struct device *dev = &spi->dev;
+	const struct st7789v_cfg_t *cfg;
+	struct mipi_dbi_dev *dbidev;
+	struct st7789v_priv *priv;
+	struct drm_device *drm;
+	struct mipi_dbi *dbi;
+	struct gpio_desc *dc;
+	u32 rotation = 0;
+	int ret;
+
+	cfg = device_get_match_data(&spi->dev);
+	if (!cfg)
+		cfg = (void *)spi_get_device_id(spi)->driver_data;
+
+	priv = devm_drm_dev_alloc(dev, &st7789v_driver,
+				  struct st7789v_priv, dbidev.drm);
+	if (IS_ERR(priv))
+		return PTR_ERR(priv);
+
+	dbidev = &priv->dbidev;
+	priv->cfg = cfg;
+
+	dbi = &dbidev->dbi;
+	drm = &dbidev->drm;
+
+	dbi->reset = devm_gpiod_get(dev, "reset", GPIOD_OUT_HIGH);
+	if (IS_ERR(dbi->reset)) {
+		DRM_DEV_ERROR(dev, "Failed to get gpio 'reset'\n");
+		return PTR_ERR(dbi->reset);
+	}
+
+	dc = devm_gpiod_get(dev, "dc", GPIOD_OUT_LOW);
+	if (IS_ERR(dc)) {
+		DRM_DEV_ERROR(dev, "Failed to get gpio 'dc'\n");
+		return PTR_ERR(dc);
+	}
+
+	dbidev->backlight = devm_of_find_backlight(dev);
+	if (IS_ERR(dbidev->backlight))
+		return PTR_ERR(dbidev->backlight);
+
+	device_property_read_u32(dev, "rotation", &rotation);
+
+	ret = mipi_dbi_spi_init(spi, dbi, dc);
+	if (ret)
+		return ret;
+
+	if (cfg->write_only)
+		dbi->read_commands = NULL;
+
+	dbidev->left_offset = cfg->left_offset;
+	dbidev->top_offset = cfg->top_offset;
+
+	ret = mipi_dbi_dev_init(dbidev, &st7789v_pipe_funcs, &cfg->mode,
+				rotation);
+	if (ret)
+		return ret;
+
+	drm_mode_config_reset(drm);
+
+	ret = drm_dev_register(drm, 0);
+	if (ret)
+		return ret;
+
+	spi_set_drvdata(spi, drm);
+
+	drm_fbdev_generic_setup(drm, 0);
+
+	return 0;
+}
+
+static int st7789v_remove(struct spi_device *spi)
+{
+	struct drm_device *drm = spi_get_drvdata(spi);
+
+	drm_dev_unplug(drm);
+	drm_atomic_helper_shutdown(drm);
+
+	return 0;
+}
+
+static void st7789v_shutdown(struct spi_device *spi)
+{
+	drm_atomic_helper_shutdown(spi_get_drvdata(spi));
+}
+
+static struct spi_driver st7789v_spi_driver = {
+	.driver = {
+		.name = "st7789v",
+		.of_match_table = st7789v_of_match,
+	},
+	.id_table = st7789v_id,
+	.probe = st7789v_probe,
+	.remove = st7789v_remove,
+	.shutdown = st7789v_shutdown,
+};
+module_spi_driver(st7789v_spi_driver);
+
+MODULE_DESCRIPTION("Sitronix ST7735V DRM driver");
+MODULE_AUTHOR("Major Tom <493281372@qq.com>");
+MODULE_LICENSE("GPL");
-- 
2.25.1

